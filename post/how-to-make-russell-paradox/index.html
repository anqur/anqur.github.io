<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="initial-scale=1">
  <title>Horrible RAM</title>
</head>

<body>
  <header>
    <a href="/">Horrible RAM</a>
  </header>

  <main>
  <h1 id="如何制造罗素悖论">如何制造罗素悖论</h1>
<p>在高中数学课上我们已接触到了 <em>集合论</em> 的一些基本概念, 同时它也是高考中的常客, 但也许因为应试的要求, 我们可能没有在课程中了解过它的历史和缺陷. 高中时期, 我们接触的集合论的定义由 Georg Contor (康托尔) 提出, 他也是集合论最初的缔造者. 根据他的想法,</p>
<blockquote>
<p>由一些确定的且相互区别的对象汇集而组成的一个整体, 称为 <em>集合</em> (<em>set</em>), 组成该集合的对象称为它的 <em>元素</em> (<em>element</em>).</p>
</blockquote>
<p>不正式地, 可以简单地理解为 <em>对象的集合</em> (<em>collection of objects</em>).</p>
<p>至于对象是怎么组合的, 则有以下两个重要的原则:</p>
<ul>
<li><em>外延公理</em> (<em>axiom of extensionality</em>): 一个集合由它的元素完全决定. 也就是说, 若两个集合的元素相同, 则他们为同一个集合 <span class="math display">\[
\forall A \forall B
  (\forall x (x \in A \Leftrightarrow x \in B) \Rightarrow A = B)
\]</span></li>
<li><em>概括公理模式</em> (<em>axiom schema of comprehension</em>)<sup>†</sup>: 对任意一个性质 <span class="math inline">\(P\)</span> (也可说一个 谓词/predicate), 均存在一个集合 <span class="math inline">\(S\)</span>, 它的元素恰是具有性质 <span class="math inline">\(P\)</span> 的那些对象. 根据外延公理, 这个集合是唯一的, 常表示为 <span class="math inline">\(S = \\{ x | P(x) \\}\)</span></li>
</ul>
<p>在这样的定义之下, 我们在高中就已经把玩得不亦乐乎了, 但是 Bertrand Russell (罗素) 发现了其中的矛盾:</p>
<blockquote>
<p>若令 <span class="math inline">\(T = \\{ x | x \notin x \\}\)</span>, 则 <span class="math inline">\(T\)</span> 不是一个集合.</p>
</blockquote>
<p>怎么回事? 仔细一想就明白了:</p>
<ul>
<li>设性质 <span class="math inline">\(P\)</span> 对应的谓词为 <span class="math inline">\(P(x): x \notin x\)</span>,
<ul>
<li>若 <span class="math inline">\(T \in T\)</span>, <span class="math inline">\(T\)</span> 是 <span class="math inline">\(T\)</span> 的一员, 则 <span class="math inline">\(T\)</span> 应符合性质 <span class="math inline">\(P\)</span>, 所以 <span class="math inline">\(T \notin T\)</span> 成立, 发生矛盾</li>
<li>若 <span class="math inline">\(T \notin T\)</span>, 则根据性质 <span class="math inline">\(P\)</span>, <span class="math inline">\(T\)</span> 是 <span class="math inline">\(T\)</span> 的一员, 即 <span class="math inline">\(T \in T\)</span> 成立, 发生矛盾</li>
</ul></li>
</ul>
<p>这就是著名的 <em>罗素悖论</em> (<em>Russell's paradox</em>), 因此康德尔版本的集合论也称 <em>朴素集合论</em> (<em>naive set theory</em>), 且引发了第三次数学危机. <em>理发师悖论</em> 是罗素悖论的一种通俗说法, 内容为:</p>
<blockquote>
<p>城里的理发师说, 他只为城里所有不为自己刮胡子的人刮胡子. 那么他要给自己刮胡子吗?</p>
</blockquote>
<p>但这篇文章是讲 <strong>如何制造罗素悖论</strong> 的, 还有其他的方法吗? 当然有, 咱们再来一次. 为了克服朴素集合论中的悖论, 我们可以做出一些修改和引入, 所形成的新的公理化系统 <em>ZFC</em> 就是所谓的现代集合论了, 全称 <em>Zermelo-Fraenkel 集合论</em>, 名字里头的 <em>C</em> 表示 <em>选择公理</em> (<em>axiom of choice</em>), 但这里为了再造一次罗素悖论还不需要.</p>
<p>我们引入一个比集合更广泛的概念, 称作 <em>类</em> (<em>class</em>). 所有的集合都是类, 但类不一定是集合. 不是集合的类叫做 <em>真类</em> (<em>proper class</em>), 例如上面的 <span class="math inline">\(T\)</span>. 之后我们修改并沿用以上的原则:</p>
<ul>
<li>外延公理: 一个类由它的元素完全决定</li>
<li>概括公理模式: 对于任意一个性质 <span class="math inline">\(P\)</span>, 均存在一个类 <span class="math inline">\(S\)</span>, 它的元素恰是具有性质 <span class="math inline">\(P\)</span> 的那些对象</li>
</ul>
<p>引入一个 <em>空集</em> (<em>empty set</em>) 的概念, 这个不难理解.</p>
<ul>
<li>空集公理: 存在一个不含任何元素的集合, 成为空集. 根据外延公理, 空集是唯一的, 记作 <span class="math inline">\(\varnothing\)</span></li>
</ul>
<p>接着我们引入一个新的原则, 称作 <em>子集分离公理</em>.</p>
<ul>
<li>子集分离公理: 对任意性质 <span class="math inline">\(P\)</span> 和集合 <span class="math inline">\(S\)</span>, 存在集合 <span class="math inline">\(\overset{\sim}{S} = \\{ x | x \in x \land P(x) \\}\)</span></li>
</ul>
<p>其他的公理, 包括著名的 <em>类选择公理</em> 和 <em>替换原则</em> 等等, 在此先不展开讨论, 有了子集分离公理, 可以达到我们再次创造罗素悖论的目的.</p>
<blockquote>
<p>若令 <span class="math inline">\(V = \\{ x | x = x \\}\)</span>, 则 <span class="math inline">\(V\)</span> 是一个真类.</p>
</blockquote>
<p>哦? 这又是为什么呢? 当然这次创造罗素悖论的方法也非常巧妙</p>
<ul>
<li>定义类 <span class="math inline">\(T = \\{ x | x \in V \land x \notin x \\}\)</span>, 则根据子集分离公理,
<ul>
<li><span class="math inline">\(V\)</span> 这个类, 包括了 <strong>一切所有的类, 也包括它自己</strong>, 因为不难得出, 所有的类和它本身都是 <em>同一个类</em></li>
<li>定义出 <span class="math inline">\(T\)</span> 后, <span class="math inline">\(T\)</span> 也应该是类 <span class="math inline">\(V\)</span> 中的一员, 即 <span class="math inline">\(T \in V\)</span>, 那又出现了
<ul>
<li>当 <span class="math inline">\(T \in T\)</span>, 则符合性质 <span class="math inline">\(x \notin x\)</span>, 导出 <span class="math inline">\(T \notin T\)</span>, 发生矛盾</li>
<li>当 <span class="math inline">\(T \notin T\)</span>, 则符合性质 <span class="math inline">\(x \notin x\)</span>, 导出 <span class="math inline">\(T \in T\)</span>, 发生矛盾</li>
</ul></li>
</ul></li>
</ul>
<p>为了让系统保持 <em>一致</em> (<em>consistent</em>) 需要更多公理的引入, 在此就不继续介绍了. 但是文章这个 "创造罗素悖论" 的目的到底是什么呢? 其实很多用来描述数学概念的理论, 都会多多少少用到 ZFC 的内容, 尤其是 <em>范畴论</em> (<em>category theory</em>), <em>类型论</em> (<em>type theory</em>) 等等, 而在和计算机科学息息相关的类型论中还有能模拟罗素悖论的 <em>Girard 悖论</em> (<em>Girard's paradox</em>), 接着是同样非常重要的 <em>代数结构</em> (<em>algebraic structures</em>) 等等, 这就涉及到 <em>群论</em> (<em>group theory</em>), <em>同伦学</em> (<em>homotopy theory</em>), <em>拓扑学</em> (<em>topology</em>) 等等重要的数学分支了.</p>
<p>可是往上回顾, <strong>无意中创造悖论是多么的简单.</strong></p>
<p>让整个系统保持一致性是多么宏伟的工程. 这又让我联想起了令人闻风丧胆的 <em>GIT</em> 了, 当然不是 Linus Torvalds 写的那个版本管理软件, GIT 说的是 <em>Gödel's incompleteness theorems</em>, 即 <em>哥德尔不完备定理</em>:</p>
<blockquote>
<p>任何逻辑自洽的形式系统, 只要蕴涵 <em>皮亚诺公理</em> (<em>Peano axioms</em>), 它就不能用于证明它本身的兼容性.</p>
</blockquote>
<p>好了, 就写到这里啦.</p>
<h2 id="notes">Notes</h2>
<ul>
<li>†: 概括公理模式在现代集合论中称为 <em>axiom schema of <strong>unrestricted</strong> comprehension</em>, 因为现代的概括公理模式是 <em>带有限制的</em>. 至于什么是 <em>公理模式</em> (<em>axiom schema</em>), 它是 <em>公理</em> (<em>axiom</em>) 广义化后的概念, 这里不细谈</li>
</ul>

  </main>

  <footer>
    END
  </footer>

  <script type="text/javascript" async src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
  </script>
</body>

</html>

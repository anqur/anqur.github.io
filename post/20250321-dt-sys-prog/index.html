<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="initial-scale=1">

    <title>Internal Blog Theory | Anqur</title>
    <link rel="stylesheet" href="/style/post.css">
    <link rel="stylesheet" href="/style/highlight.css">

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.18/dist/katex.min.css"
          integrity="sha384-veTAhWILPOotXm+kbR5uY7dRamYLJf58I7P+hJhjeuc7hsMAkJHTsPahAl0hBST0" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.18/dist/katex.min.js"
            integrity="sha384-v6mkHYHfY/4BWq54f7lQAdtIsoZZIByznQ3ZqN38OL4KCsrxo31SLlPiak7cj/Mg"
            crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.18/dist/contrib/auto-render.min.js"
            integrity="sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh" crossorigin="anonymous"
            onload="renderMathInElement(document.body);"></script>
</head>

<body>
<header>
    <h1><a href="/">Internal Blog Theory</a></h1>
</header>

<main>
    <article>
        <h1 id="systems-programming-in-dependent-types">Systems programming in
dependent types</h1>
<p>Done:</p>
<ul>
<li>Coeffects over effects.</li>
<li>Pointer read/write intrinsics (type of pointers, memory locations,
and memory layout proofs).</li>
<li>Invalidate on-stack locations.</li>
<li>How to deal with <code>char const*</code>.</li>
<li>How to implement RAII (<code>defer</code> is bad):
<code>defer</code> as the affine logic. <code>Defer</code> trait. The
<code>defer</code> logic would be run at the block end, so we don't
consider the <code>guard</code> keyword in the related C proposal.</li>
<li><code>auto f() -&gt; T</code> should be everywhere: Good for long
return types.</li>
<li>How to deal with <code>char[]</code> (<code>char</code> slice,
<del>flexible array member, and VLA</del>): VLA should be dropped, and
FAM should be implemented using static reflection.</li>
<li>Dynamic memory safety, hardened runtime, and Clang's bounds
checking.</li>
<li>How to deal with <code>void</code> and <code>void*</code>:
<code>void*</code> is just an unknown memory layout, it should be easy
to tag via a generic <code>l: Addr</code> location.</li>
<li>Initializer, constructor, <code>Default</code> trait? We allow
custom empty initialization at the definition of a struct (just like
C++), but the parameters would be annotated with quantity
<code>0</code>, which means they need to be calculated in the
compile-time, which rejects runtime logic.</li>
<li>How to deal with many POSIX standard definitions? E.g.
<code>sockaddr_in</code> (struct type) and <code>AF_INET</code>
enumeration value: We could define them manually at first, maybe later
we could have some libclang-based code generation.</li>
</ul>
<p>Not planned:</p>
<ul>
<li><del>Better way to initialize things at runtime using
oneliners.</del> No such situations needed.</li>
<li><del>Dart style syntax <code>..</code>, or Kotlin <code>with</code>,
or Java's builder pattern.</del> RVO is not good for everywhere.</li>
</ul>
<p>Doing:</p>
<ul>
<li>Must-use initializer:
<ul>
<li>Call-by-reference, unified <code>.</code>: We don't do this, because
C users would be confused with a gone <code>-&gt;</code> syntax, and
once <code>-&gt;</code> is preserved, <code>a.f(1, 2)</code> and
<code>a-&gt;f(1, 2)</code> would be both valid and confusing due to
call-by-reference.</li>
<li>How to be must-use?</li>
<li>Flat-level method definitions?</li>
</ul></li>
</ul>

    </article>
</main>

<footer>
    <p>
        All posts follow the <code>cc-by-4.0</code> license. See <a href="//github.com/anqur/anqur.github.io/issues">issues</a>?
    </p>
</footer>
</body>

</html>

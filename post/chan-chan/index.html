<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="initial-scale=1">
  <title>Horrible RAM</title>
</head>

<body>
  <header>
    <a href="/">Horrible RAM</a>
  </header>

  <main>
  <h1 id="chan-chan">Chan Chan</h1>
<p>嗯哼, 这篇文当然不是关于推荐 Buena Vista Social Club 那首脍炙人口的歌曲 <a href="https://www.youtube.com/watch?v=KODWcrncnUU">Chan Chan</a> 的昂.</p>
<p><code>chan</code> 作为通道是 Go 语言 CSP 模型中的重要组成部分, 我在学习一些 Go 语言的同步机制时, 偶然间发现 <code>chan chan interface{}</code> 这种同步的方式. 举个例子, 如果要原子地增加一个全局整型变量的值, 可以简单的使用一个互斥锁 <code>sync.Mutex</code> 保护临界区. 为了比较性能和内存使用情况, 引入 <code>testing</code> 模块帮助我们完成测试.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">import</span> (</a>
<a class="sourceLine" id="cb1-2" title="2">    <span class="st">&quot;sync&quot;</span></a>
<a class="sourceLine" id="cb1-3" title="3">    <span class="st">&quot;testing&quot;</span></a>
<a class="sourceLine" id="cb1-4" title="4">)</a></code></pre></div>
<p>假设我们要原子自增的次数为一百万次, 并用不占用内存的空结构体 <code>struct{}</code> 作为同步需要发送的消息类型.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">const</span> NUM = <span class="dv">1000000</span></a>
<a class="sourceLine" id="cb2-2" title="2"></a>
<a class="sourceLine" id="cb2-3" title="3"><span class="kw">type</span> Msg <span class="kw">struct</span>{}</a></code></pre></div>
<p>我们先实现一个使用互斥锁的 benchmark 帮助我们做比较. 顺带一提, <code>-race</code> 选项开启 race detector 的功能只支持 64 位机唔.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">func</span> BenchmarkMutex(b *testing.B) {</a>
<a class="sourceLine" id="cb3-2" title="2">    <span class="co">// sync.WaitGroup 避免我们再多用一条通道同步两个 goroutine.</span></a>
<a class="sourceLine" id="cb3-3" title="3">    <span class="kw">var</span> wg sync.WaitGroup</a>
<a class="sourceLine" id="cb3-4" title="4">    <span class="kw">var</span> mtx sync.Mutex</a>
<a class="sourceLine" id="cb3-5" title="5"></a>
<a class="sourceLine" id="cb3-6" title="6">    n := <span class="dv">0</span></a>
<a class="sourceLine" id="cb3-7" title="7">    wg.Add(<span class="dv">2</span>)</a>
<a class="sourceLine" id="cb3-8" title="8"></a>
<a class="sourceLine" id="cb3-9" title="9">    <span class="kw">for</span> i := <span class="dv">0</span>; i &lt; <span class="dv">2</span>; i++ {</a>
<a class="sourceLine" id="cb3-10" title="10">        <span class="co">// 开启两个 goroutine.</span></a>
<a class="sourceLine" id="cb3-11" title="11">        <span class="kw">go</span> <span class="kw">func</span>() {</a>
<a class="sourceLine" id="cb3-12" title="12">            <span class="co">// 延迟 `wg&#39; 的提醒.</span></a>
<a class="sourceLine" id="cb3-13" title="13">            <span class="kw">defer</span> wg.Done()</a>
<a class="sourceLine" id="cb3-14" title="14">            <span class="kw">for</span> i := <span class="dv">0</span>; i &lt; NUM; i++ {</a>
<a class="sourceLine" id="cb3-15" title="15">                mtx.Lock()</a>
<a class="sourceLine" id="cb3-16" title="16">                n++</a>
<a class="sourceLine" id="cb3-17" title="17">                mtx.Unlock()</a>
<a class="sourceLine" id="cb3-18" title="18">            }</a>
<a class="sourceLine" id="cb3-19" title="19">        }()</a>
<a class="sourceLine" id="cb3-20" title="20">    }</a>
<a class="sourceLine" id="cb3-21" title="21"></a>
<a class="sourceLine" id="cb3-22" title="22">    wg.Wait()</a>
<a class="sourceLine" id="cb3-23" title="23">}</a></code></pre></div>
<p>所以 <code>chan chan interface{}</code> 到底是什么东西呢? 从字面上理解, <code>chan chan interface{}</code> 是用于传输 <code>chan interface{}</code> 的通道. 直接想确实很晦涩, 其实用 C/S 模型的思路就很好理解了:</p>
<ul>
<li>客户端通过 <code>chan chan interface{}</code> 发送一个 <code>chan interface{}</code> 给服务端,</li>
<li>服务端通过这个 <code>chan interface{}</code> 把回应信息发回给客户端</li>
</ul>
<p>我们来瞥一眼这个 benchmark 的内容吧.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">func</span> BenchmarkChanChan(b *testing.B) {</a>
<a class="sourceLine" id="cb4-2" title="2">    <span class="kw">var</span> wg sync.WaitGroup</a>
<a class="sourceLine" id="cb4-3" title="3"></a>
<a class="sourceLine" id="cb4-4" title="4">    n := <span class="dv">0</span></a>
<a class="sourceLine" id="cb4-5" title="5">    wg.Add(<span class="dv">2</span>)</a>
<a class="sourceLine" id="cb4-6" title="6"></a>
<a class="sourceLine" id="cb4-7" title="7">    <span class="co">// Request 通道.</span></a>
<a class="sourceLine" id="cb4-8" title="8">    req := <span class="bu">make</span>(<span class="kw">chan</span> <span class="kw">chan</span> Msg)</a>
<a class="sourceLine" id="cb4-9" title="9"></a>
<a class="sourceLine" id="cb4-10" title="10">    <span class="co">// 客户端.</span></a>
<a class="sourceLine" id="cb4-11" title="11">    <span class="kw">go</span> <span class="kw">func</span>() {</a>
<a class="sourceLine" id="cb4-12" title="12">        <span class="kw">defer</span> wg.Done()</a>
<a class="sourceLine" id="cb4-13" title="13">        <span class="kw">for</span> i := <span class="dv">0</span>; i &lt; NUM; i++ {</a>
<a class="sourceLine" id="cb4-14" title="14">            <span class="co">// Response 通道.</span></a>
<a class="sourceLine" id="cb4-15" title="15">            res := <span class="bu">make</span>(<span class="kw">chan</span> Msg)</a>
<a class="sourceLine" id="cb4-16" title="16">            <span class="co">// 发送这个 chan 给服务端返回回应.</span></a>
<a class="sourceLine" id="cb4-17" title="17">            req &lt;- res</a>
<a class="sourceLine" id="cb4-18" title="18">            <span class="co">// 从回应中拿出信息, 在此不需要这个值所以抛弃.</span></a>
<a class="sourceLine" id="cb4-19" title="19">            &lt;-res</a>
<a class="sourceLine" id="cb4-20" title="20">            n++</a>
<a class="sourceLine" id="cb4-21" title="21">        }</a>
<a class="sourceLine" id="cb4-22" title="22">    }()</a>
<a class="sourceLine" id="cb4-23" title="23"></a>
<a class="sourceLine" id="cb4-24" title="24">    <span class="co">// 服务端.</span></a>
<a class="sourceLine" id="cb4-25" title="25">    <span class="kw">go</span> <span class="kw">func</span>() {</a>
<a class="sourceLine" id="cb4-26" title="26">        <span class="kw">defer</span> wg.Done()</a>
<a class="sourceLine" id="cb4-27" title="27">        <span class="kw">for</span> i := <span class="dv">0</span>; i &lt; NUM; i++ {</a>
<a class="sourceLine" id="cb4-28" title="28">            <span class="co">// 拿到用作回应的 chan.</span></a>
<a class="sourceLine" id="cb4-29" title="29">            c := &lt;-req</a>
<a class="sourceLine" id="cb4-30" title="30">            <span class="co">// 回应一个空信息.</span></a>
<a class="sourceLine" id="cb4-31" title="31">            c &lt;- Msg{}</a>
<a class="sourceLine" id="cb4-32" title="32">            n++</a>
<a class="sourceLine" id="cb4-33" title="33">        }</a>
<a class="sourceLine" id="cb4-34" title="34">    }()</a>
<a class="sourceLine" id="cb4-35" title="35"></a>
<a class="sourceLine" id="cb4-36" title="36">    wg.Wait()</a>
<a class="sourceLine" id="cb4-37" title="37">}</a></code></pre></div>
<p>你可能在想为什么要这么麻烦呢? 在你的脑子蹦出更多的问题之前, 这里其实有一些事实需要澄清, 首先, 我们的 <code>chan chan interface{}</code> 已经在抽象的层面做了一个很大步伐的跳跃, 从各种文档和书籍中我们可以读到的, 并需要我们跟随步伐来理解的其实长这样:</p>
<ul>
<li>Go 语言中的 <code>chan</code> 最好用于单向传输, 甚至使用 <code>chan&lt;-</code> 和 <code>&lt;-chan</code> 标识方向, 可以说是标识 read/write-only 的属性</li>
<li><code>chan</code> 用于双工 (bidirectional) 操作被认为是不可取的</li>
<li>双向沟通可以使用两个 <code>chan</code>, 一个用于请求, 一个用于回应</li>
</ul>
<p>而我们的 <code>chan chan interface{}</code> 其实就是第三点的变体罢了. 既然我们提到了第三点, 不妨试一试更好理解的 请求/回应 双 <code>chan</code> 的方式来进行同步, 也就是经典的 <em>ping pong</em> 或 <em>wiff waff</em> 的模型.</p>
<blockquote>
<p>打乒乓球!</p>
</blockquote>
<div class="sourceCode" id="cb5"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">func</span> BenchmarkPingPong(b *testing.B) {</a>
<a class="sourceLine" id="cb5-2" title="2">    <span class="kw">var</span> wg sync.WaitGroup</a>
<a class="sourceLine" id="cb5-3" title="3"></a>
<a class="sourceLine" id="cb5-4" title="4">    n := <span class="dv">0</span></a>
<a class="sourceLine" id="cb5-5" title="5">    wg.Add(<span class="dv">2</span>)</a>
<a class="sourceLine" id="cb5-6" title="6"></a>
<a class="sourceLine" id="cb5-7" title="7">    ping := <span class="bu">make</span>(<span class="kw">chan</span> Msg, <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb5-8" title="8">    pong := <span class="bu">make</span>(<span class="kw">chan</span> Msg, <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb5-9" title="9"></a>
<a class="sourceLine" id="cb5-10" title="10">    <span class="co">// 定义球拍动作.</span></a>
<a class="sourceLine" id="cb5-11" title="11">    racket := <span class="kw">func</span>(c1 <span class="kw">chan</span> Msg, c2 <span class="kw">chan</span> Msg) {</a>
<a class="sourceLine" id="cb5-12" title="12">        <span class="kw">defer</span> wg.Done()</a>
<a class="sourceLine" id="cb5-13" title="13">        <span class="kw">for</span> i := <span class="dv">0</span>; i &lt; NUM; i++ {</a>
<a class="sourceLine" id="cb5-14" title="14">            m := &lt;-c1</a>
<a class="sourceLine" id="cb5-15" title="15">            n++</a>
<a class="sourceLine" id="cb5-16" title="16">            c2 &lt;- m</a>
<a class="sourceLine" id="cb5-17" title="17">        }</a>
<a class="sourceLine" id="cb5-18" title="18">    }</a>
<a class="sourceLine" id="cb5-19" title="19"></a>
<a class="sourceLine" id="cb5-20" title="20">    <span class="co">// 球拍 1 从球桌的 ping 端打到 pong.</span></a>
<a class="sourceLine" id="cb5-21" title="21">    <span class="kw">go</span> racket(ping, pong)</a>
<a class="sourceLine" id="cb5-22" title="22">    <span class="co">// 球拍 2 从球桌的 pong 端打到 ping.</span></a>
<a class="sourceLine" id="cb5-23" title="23">    <span class="kw">go</span> racket(pong, ping)</a>
<a class="sourceLine" id="cb5-24" title="24">    <span class="co">// 往球桌的其中一端放入一颗球.</span></a>
<a class="sourceLine" id="cb5-25" title="25">    ping &lt;- Msg{}</a>
<a class="sourceLine" id="cb5-26" title="26"></a>
<a class="sourceLine" id="cb5-27" title="27">    wg.Wait()</a>
<a class="sourceLine" id="cb5-28" title="28">}</a></code></pre></div>
<p>这里有一个非常非常重要的细节, 两个通道在此使用了 <code>make(chan Msg, 2)</code> 的构造方法, 给通道定义了容量为 2 的缓冲区 (通道默认 unbuffered), 这样在 放入/取出 消息的时候就没有堵塞的必要了, 也不会发生死锁 (想象一下协程的 yield 操作!).</p>
<p>最后, 以下是在我机子里跑出来的性能报告, 可以做个参考.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb6-1" title="1">$ <span class="ex">go</span> test -bench . -benchmem</a>
<a class="sourceLine" id="cb6-2" title="2"><span class="ex">goos</span>: linux</a>
<a class="sourceLine" id="cb6-3" title="3"><span class="ex">goarch</span>: amd64</a>
<a class="sourceLine" id="cb6-4" title="4"><span class="ex">BenchmarkMutex-4</span>        1000000000           0.06 ns/op        0 B/op          0 allocs/op</a>
<a class="sourceLine" id="cb6-5" title="5"><span class="ex">BenchmarkChanChan-4</span>     2000000000           0.31 ns/op        0 B/op          0 allocs/op</a>
<a class="sourceLine" id="cb6-6" title="6"><span class="ex">BenchmarkPingPong-4</span>     2000000000           0.27 ns/op        0 B/op          0 allocs/op</a>
<a class="sourceLine" id="cb6-7" title="7"><span class="ex">PASS</span></a></code></pre></div>
<p>可见, <code>chan chan interface{}</code> 的效率一般比两者要低.</p>
<blockquote>
<p>要你何用...</p>
</blockquote>
<p>当然, 妙用还是有滴.</p>
<p>如果熟悉 C++11 中的线程间同步机制的话, 一定会知道 <code>std::future&lt;T&gt;</code> 这个结构, 它可以承载 <code>std::async()</code>, <code>std::packaged_task&lt;R(Args...)&gt;</code> 以及 <code>std::promise&lt;R&gt;</code> 三种机制的异步结果. 是的, <code>chan chan interface{}</code> 第一眼过去难道长得不像 promise 吗! 为此我写了一个基于它的 future/promise 库, 其实 50 行代码都不到. 下面是这个库的一个基本的例子, 看两眼应该可以理解 <code>chan chan</code> 是怎么被运用在其中的相信我.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">package</span> main</a>
<a class="sourceLine" id="cb7-2" title="2"></a>
<a class="sourceLine" id="cb7-3" title="3"><span class="kw">import</span> (</a>
<a class="sourceLine" id="cb7-4" title="4">    <span class="st">&quot;fmt&quot;</span></a>
<a class="sourceLine" id="cb7-5" title="5">    <span class="st">&quot;time&quot;</span></a>
<a class="sourceLine" id="cb7-6" title="6"></a>
<a class="sourceLine" id="cb7-7" title="7">    <span class="st">&quot;github.com/anqurvanillapy/profut&quot;</span></a>
<a class="sourceLine" id="cb7-8" title="8">)</a>
<a class="sourceLine" id="cb7-9" title="9"></a>
<a class="sourceLine" id="cb7-10" title="10"><span class="kw">func</span> main() {</a>
<a class="sourceLine" id="cb7-11" title="11">    p := &amp;profut.Promise{}</a>
<a class="sourceLine" id="cb7-12" title="12">    f := p.GetFuture()</a>
<a class="sourceLine" id="cb7-13" title="13"></a>
<a class="sourceLine" id="cb7-14" title="14">    <span class="kw">go</span> <span class="kw">func</span>(p *Promise) {</a>
<a class="sourceLine" id="cb7-15" title="15">        <span class="co">// 类似 C++11 中的 std::promise::set_value_at_thread_exit</span></a>
<a class="sourceLine" id="cb7-16" title="16">        <span class="kw">defer</span> p.SetValue(<span class="dv">42</span>)</a>
<a class="sourceLine" id="cb7-17" title="17">        time.Sleep(<span class="dv">100</span> * time.Millisecond)</a>
<a class="sourceLine" id="cb7-18" title="18">    }(p)</a>
<a class="sourceLine" id="cb7-19" title="19"></a>
<a class="sourceLine" id="cb7-20" title="20">    f.Wait()</a>
<a class="sourceLine" id="cb7-21" title="21">    fmt.Println(f.Get())</a>
<a class="sourceLine" id="cb7-22" title="22">    <span class="co">// Output: 42</span></a>
<a class="sourceLine" id="cb7-23" title="23">}</a></code></pre></div>
<p>当然, 异常的处理和 promises chaining 所需的 <code>Then</code> 接口还有待实现, 可以在这个 <a href="https://github.com/anqurvanillapy/profut">仓库</a> 里找到相应的代码. <code>chan chan</code> 的使用先说到这吧.</p>

  </main>

  <footer>
    END
  </footer>

  <script type="text/javascript" async src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
  </script>
</body>

</html>

<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="initial-scale=1">

  <title>tl;dw | Anqur</title>
  <link rel="stylesheet" href="/style/post.css">
  <link rel="stylesheet" href="/scripts/highlight.css">
</head>

<body>
  <header>
    <h1><a href="/">tl;dw</a></h1>
  </header>

  <main>
    <article>
      <h1 id="transcript-infty-category-theory-for-undergraduates">Transcript: <span class="math inline">\(\infty\)</span>-Category Theory for Undergraduates</h1>
<blockquote>
<p>This is the transcript of the <a href="http://www.math.jhu.edu/~eriehl/berkeley-logic.pdf">slides</a> from Emily Riehl's talk <em><span class="math inline">\(\infty\)</span>-Category Theory for Undergraduates</em> (<a href="http://www.math.jhu.edu/~eriehl/berkeley-logic.mp4">video</a>), which is absolutely a great introduction to modern type theory and mathematics.</p>
</blockquote>
<ul>
<li>Berkeley Logic Colloquium</li>
<li>Emily Riehl</li>
<li>7 May 2020</li>
</ul>
<p>Thesis: If future undergraduates' foundational understanding of mathematical proof were based on Homotopy Type Theory (HoTT) then we could teach them <span class="math inline">\(\infty\)</span>-category theory - much as we teach today's undergraduates abstract algebra.</p>
<ol type="1">
<li>ACT I: Undergraduate-level informal HoTT</li>
<li>ACT II: <span class="math inline">\(\infty\)</span>-category theory</li>
</ol>
<h2 id="act-i-undergraduate-level-informal-hott">ACT I: Undergraduate-level informal HoTT</h2>
<p><em>Dependant type theory</em> is a formal system of inference rules, that combine to form derivations. There are four kinds of "well-formed formulas" called <em>judgements</em>, including:</p>
<ul>
<li><span class="math inline">\(\Gamma \vdash A \  type\)</span> - "<span class="math inline">\(A\)</span> is a type"</li>
<li><span class="math inline">\(\Gamma \vdash a : A\)</span> - "<span class="math inline">\(a\)</span> is a term of type <span class="math inline">\(A\)</span>"</li>
</ul>
<p>Here <span class="math inline">\(\Gamma\)</span> is a <em>context</em> which declares the types of any variables that appear. e.g</p>
<ul>
<li><span class="math inline">\(\Gamma, x : A \vdash B(x) \  type\)</span> - "a <em>family of types</em> over <span class="math inline">\(A\)</span>"</li>
<li><span class="math inline">\(\Gamma, x : A \vdash b(x) : B(x)\)</span> - "a <em>family of terms</em>"</li>
</ul>
<blockquote>
<ul>
<li><span class="math inline">\(n : \mathbb{N} \vdash \mathbb{R}^n \  type\)</span></li>
<li><span class="math inline">\(n : \mathbb{N} \vdash \bar{0} : \mathbb{R}^n\)</span></li>
</ul>
</blockquote>
<p>There are four kinds of <em>rules</em> (in place of axioms) that can be used in derivations:</p>
<ol type="1">
<li><strong>Formation rules</strong> form new types:
<ul>
<li><span class="math inline">\(^\times\)</span><em>formation</em>: given types <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> there is a <em>product type</em> <span class="math inline">\(A \times B\)</span> <span class="math display">\[\frac{\Gamma \vdash A \  type \qquad \Gamma \vdash B \  type}{\Gamma \vdash A \times B \  type}\]</span></li>
</ul></li>
<li><strong>Introduction rules</strong> introduce new terms:
<ul>
<li><span class="math inline">\(^\times\)</span><em>introduction</em>: given terms <span class="math inline">\(a : A\)</span> and <span class="math inline">\(b : B\)</span> there is a term <span class="math inline">\((a, b) : A \times B\)</span> <span class="math display">\[\frac{\Gamma \vdash a : A \qquad \Gamma \vdash b : B}{\Gamma \vdash (a, b) : A \times B}\]</span></li>
</ul></li>
<li><strong>Elimination rules</strong> use the new terms:
<ul>
<li><span class="math inline">\(^\times\)</span><em>elimination</em>: given a term <span class="math inline">\(p : A \times B\)</span> there are terms <span class="math inline">\(pr_1(p) : A\)</span> and <span class="math inline">\(pr_2(p) : B\)</span> <span class="math display">\[\frac{\Gamma \vdash p : A \times B}{\Gamma \vdash pr_1(p) : A}\]</span> <span class="math display">\[\frac{\Gamma \vdash p : A \times B}{\Gamma \vdash pr_2(p) : B}\]</span></li>
</ul></li>
<li><strong>Computation rules</strong> relate <code>2</code> and <code>3</code></li>
</ol>
<p><em>Function types</em> are generated by the rules:</p>
<ul>
<li><span class="math inline">\(^\rightarrow\)</span><em>formation</em>: given types <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>, there is a type <span class="math inline">\(A \rightarrow B\)</span></li>
<li><span class="math inline">\(^\rightarrow\)</span><em>introduction</em>: if in the <em>context of any term</em> <span class="math inline">\(x : A\)</span> there is a term <span class="math inline">\(b(x) : B\)</span>, then there is a term <span class="math inline">\(\lambda x . b(x) : A \rightarrow B\)</span> <span class="math display">\[\frac{\Gamma, x : A \vdash b(x) : B}{\Gamma \vdash \lambda x . b(x) : A \rightarrow B}\]</span></li>
<li><span class="math inline">\(^\rightarrow\)</span><em>elimination</em>: given terms <span class="math inline">\(f : A \rightarrow B\)</span> and <span class="math inline">\(a : A\)</span>, there is a term <span class="math inline">\(f(a) : B\)</span></li>
<li>And two <em>computation</em> rules<a href="#footnote-1"><sup>1</sup></a> <a id="footnote-ref-1"></a></li>
</ul>
<p>A proposition is <strong>proven</strong> by <strong>constructing a term</strong> in the type that encodes its statement.</p>
<details>
<summary> <em>Proposition:</em> For any types <span class="math inline">\(P\)</span> and <span class="math inline">\(Q\)</span>, there is a term <span class="math inline">\(modus{\text -}ponens : P \times (P \rightarrow Q) \rightarrow Q\)</span>. </summary>
<p>
<em>Proof:</em> By <span class="math inline">\(^\rightarrow\)</span><em>introduction</em> we must explain how to use a term <span class="math inline">\(x : P \times (P \rightarrow Q)\)</span> to prove a term of type <span class="math inline">\(Q\)</span>. By <span class="math inline">\(^\times\)</span><em>elimination</em> from <span class="math inline">\(x\)</span> we get terms <span class="math inline">\(pr_1(x) : P\)</span> and <span class="math inline">\(pr_2(x) : P \rightarrow Q\)</span>. By <span class="math inline">\(^\rightarrow\)</span><em>elimination</em> then <span class="math inline">\((pr_2(x))(pr_1(x)) : Q\)</span>. Ie, <span class="math inline">\(modus{\text -}ponens :\equiv \lambda x . (pr_2(x))(pr_1(x))\)</span>. <span class="math inline">\(\square\)</span>
</p>
</details>
<p>Propositions concerning <strong>mathematical equality</strong> are governed by Per Martin-Löf's <em>identity types</em>:</p>
<ul>
<li><span class="math inline">\(^=\)</span><em>formation</em>: given a type <span class="math inline">\(A\)</span> and two terms <span class="math inline">\(x, y : A\)</span>, there is a type <span class="math inline">\(x =_A y\)</span></li>
<li><span class="math inline">\(^=\)</span><em>introduction</em>: given a term <span class="math inline">\(x : A\)</span>, there is a term <span class="math inline">\(refl_x : x =_A x\)</span></li>
</ul>
<p>The elimination rule for the identity type can be packaged into the principal of <em>path induction</em>:</p>
<p><strong>Path induction:</strong> Given any type family <span class="math inline">\(\Gamma, x, y : A, p : x =_A y \vdash B(x, y, p) \  type\)</span>, to produce a term of type <span class="math inline">\(B(x, y, p)\)</span> it suffices to assume <span class="math inline">\(y\)</span> is <span class="math inline">\(x\)</span> and <span class="math inline">\(p\)</span> is <span class="math inline">\(refl_x\)</span>.</p>
<details>
<summary> <em>Lemma:</em> For any <span class="math inline">\(x, y : A\)</span>, <span class="math inline">\((x =_A y) \rightarrow (y =_A x)\)</span>. </summary>
<p>
<em>Proof:</em> By <span class="math inline">\(^\rightarrow\)</span><em>introduction</em>, we may assume <span class="math inline">\(p : x =_A y\)</span>, and must produce a term of type <span class="math inline">\(y =_A x\)</span>. By <em>path induction</em>, to inhabit the type family <span class="math inline">\(B(x, y, p) :\equiv y =_A x\)</span>, it suffices to assume <span class="math inline">\(y\)</span> is <span class="math inline">\(x\)</span> and <span class="math inline">\(p\)</span> is <span class="math inline">\(refl_x\)</span>, in which case by <span class="math inline">\(^=\)</span><em>introduction</em> we have <span class="math inline">\(relf_x : x =_A x\)</span>. <span class="math inline">\(\square\)</span>
</p>
</details>
<details>
<summary> <em>Lemma:</em> For any <span class="math inline">\(x, y, z : A\)</span>, <span class="math inline">\((x =_A y) \rightarrow ((y =_A z) \rightarrow (x =_A z))\)</span>. </summary>
<p>
<em>Proof:</em> By <span class="math inline">\(^\rightarrow\)</span><em>introduction</em>, we may assume <span class="math inline">\(p : x =_A y\)</span> and <span class="math inline">\(q : y =_A z\)</span> and seek to inhabit <span class="math inline">\(x =_A z\)</span>. By <em>path induction</em> on <span class="math inline">\(p\)</span> and then on <span class="math inline">\(q\)</span>, we may assume <span class="math inline">\(y\)</span> and <span class="math inline">\(z\)</span> are <span class="math inline">\(x\)</span> and <span class="math inline">\(p\)</span> and <span class="math inline">\(q\)</span> are <span class="math inline">\(refl_x\)</span> in which case by <span class="math inline">\(^=\)</span><em>introduction</em> we have <span class="math inline">\(refl_x : x =_A x\)</span>. <span class="math inline">\(\square\)</span>
</p>
</details>
<p>The name <em>"path induction"</em> derives from the <strong>homotopical interpretation</strong> of dependent type theory.</p>
<ul>
<li>a type <span class="math inline">\(A\)</span> <span class="math inline">\(\leftrightsquigarrow\)</span> a <strong>"space"</strong> <span class="math inline">\(A\)</span></li>
<li>a term <span class="math inline">\(a : A\)</span> <span class="math inline">\(\leftrightsquigarrow\)</span> a <strong>point</strong> <span class="math inline">\(a\)</span> in <span class="math inline">\(A\)</span></li>
<li>a term <span class="math inline">\(p : x =_A y\)</span> <span class="math inline">\(\leftrightsquigarrow\)</span> a <strong>path</strong> <span class="math inline">\(p\)</span> from <span class="math inline">\(x\)</span> to <span class="math inline">\(y\)</span> in <span class="math inline">\(A\)</span></li>
<li>a term <span class="math inline">\(h : p =_{x =_A y} q\)</span> <span class="math inline">\(\leftrightsquigarrow\)</span> a <strong>homotopy</strong> <span class="math inline">\(h\)</span> from <span class="math inline">\(p\)</span> to <span class="math inline">\(q\)</span> in <span class="math inline">\(A\)</span></li>
</ul>
<p align="center">
<img alt="Homotopy" src="homotopy.png">
</p>
<p>From this point of view, <em>symmetry</em> and <em>transitivity</em> of equality becomes <em>reversals</em> and <em>compositions</em> of <strong>paths</strong>, and of <strong>homotopies</strong>, and of <strong>higher homotopies</strong>, as summarized by a theorem of Lumsdaine and van den Berg-Garner: types inherit the structure of an <span class="math inline">\(\infty\)</span>-groupoid.</p>
<ul>
<li>a type family <span class="math inline">\(\Gamma, x : A \vdash B(x) \  type\)</span> <span class="math inline">\(\leftrightsquigarrow\)</span> a <strong>fibration</strong> over <span class="math inline">\(A\)</span></li>
<li>the <em>dependent sum</em> type <span class="math inline">\(\sum\limits_{x : A} B(x)\)</span> <span class="math inline">\(\leftrightsquigarrow\)</span> the <strong>total space</strong> of a fibration</li>
<li>the <em>dependent function</em> type <span class="math inline">\(\prod\limits_{x : A} B(x)\)</span> <span class="math inline">\(\leftrightsquigarrow\)</span> the space of <strong>sections</strong></li>
</ul>
<p align="center">
<img alt="Fibration" src="fibration.png">
</p>
<p>The homotopical interpretation inspired the following definitions:</p>
<ul>
<li><em>Definition:</em> There <strong>exists a unique</strong> term of type <span class="math inline">\(A\)</span> just when the type <span class="math inline">\(\sum\limits_{a : A} \prod\limits_{x : A} a =_A x\)</span> is inhabited, ie, just when the "space" <span class="math inline">\(A\)</span> is <em>contractible</em>.</li>
</ul>
<blockquote>
<p>Path induction expresses the contractibility of based path spaces!</p>
</blockquote>
<ul>
<li><em>Definition:</em> Types <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> are <strong>equivalent</strong> just when the following type is inhabited: <span class="math display">\[A \simeq B :\equiv \sum\limits_{f : A \rightarrow B} (\sum\limits_{g : B \rightarrow A} \prod\limits_{a : A} g(f(a)) =_A a) \times (\sum\limits_{h : B \rightarrow A} \prod\limits_{b : B} f(h(b)) =_B b)\]</span></li>
</ul>
<p>By the elimination rules for dependent sums and functions, a term in <span class="math inline">\(A \simeq B\)</span> gives terms <span class="math inline">\(f : A \rightarrow B\)</span> and <span class="math inline">\(g, h : B \rightarrow A\)</span> together with <strong>homotopies</strong> <span class="math inline">\(\alpha : \prod\limits_{a : A} g(f(a)) =_A a\)</span> and <span class="math inline">\(\beta : \prod\limits_{b : B} f(h(b)) =_B b\)</span>.</p>
<p>By composing these one can show that <span class="math inline">\(\prod\limits_{b : B} g(b) =_B h(b)\)</span>. But there is a good reason to define an <strong>equivalence</strong> to be a function <span class="math inline">\(f : A \rightarrow B\)</span> equipped with a priori distinct <em>left and right inverses</em>: given any <span class="math inline">\(x, y : (\sum\limits_{g : B \rightarrow A} \prod\limits_{a : A} g(f(a)) =_A a) \times (\sum\limits_{h : B \rightarrow A} \prod\limits_{b : B} f(h(b)) =_B b)\)</span> then <span class="math inline">\(x = y\)</span>, while the type <span class="math inline">\(\sum\limits_{g : B \rightarrow A} (\prod\limits_{a : A} g(f(a)) =_A a \times (\prod\limits_{b : B} f(g(b)) =_B b)\)</span> might have distinct terms.</p>
<h2 id="act-ii-infty-category-theory-for-undergraduates">ACT II: <span class="math inline">\(\infty\)</span>-category theory for undergraduates</h2>
<blockquote>
<p>Joint with Mike Shulman</p>
</blockquote>
<p>We work in an extension of HoTT in which types are allowed to depend on polytopes within <em>directed cubes</em>:</p>
<blockquote>
<p>Products of a directed interval <span class="math inline">\(\mathbb{I}\)</span>, which has <span class="math inline">\(0, 1 : \mathbb{I}\)</span> and <span class="math inline">\(x, y : \mathbb{I} \vdash x \leq y\)</span>.</p>
</blockquote>
<ul>
<li><span class="math inline">\(\Delta^n :\equiv \{ \langle t, ... tn \rangle : \mathbb{I}^n | t_n \leq \ldots \leq t_1 \}\)</span></li>
<li><span class="math inline">\(\partial \Delta^2 :\equiv \{ \langle s, t \rangle : \mathbb{I}^2 | (t \leq s) \land ((t = 0) \lor (t = s) \lor (s = 1)) \}\)</span></li>
<li><span class="math inline">\(\Lambda^2_1 :\equiv \{ \langle s, t \rangle : \mathbb{I}^2 | (t \leq s) \land ((t = 0) \lor (s = 1)) \}\)</span></li>
</ul>
<p align="center">
<img alt="Directed cube" src="directed-cube.png">
</p>
<p>Given polytopes <span class="math inline">\(\Phi \subset \Psi\)</span> and a function <span class="math inline">\(f : \Phi \rightarrow A\)</span> we may form an <em>extension type</em>: <span class="math inline">\(\left\langle\array{\Phi &amp; \xrightarrow{f} &amp; A \\ \downarrow &amp; \nearrow &amp; \\ \Psi &amp; &amp;}\right\rangle\)</span> <a href="#footnote-2"><sup>2</sup></a> <a id="footnote-ref-1"></a> whose terms are <span class="math inline">\(g : \Psi \rightarrow A\)</span> so that <span class="math inline">\(g |_{\Phi} \equiv f\)</span>.</p>
<blockquote>
<p>Confidential for grad students: semantics in Reedy fibrant bisimplicial sets</p>
</blockquote>
<ul>
<li><em>Definition:</em> Given <span class="math inline">\(x, y : A\)</span>, <span class="math inline">\(hom_A(x, y) :\equiv \left\{ \array{ \partial\Delta&#39; &amp; \xrightarrow{x, y} &amp; A \\ \downarrow &amp; \nearrow &amp; \\ \Delta&#39; &amp; &amp; } \right\}\)</span> <a href="#footnote-2"><sup>2</sup></a> <a id="footnote-ref-1"></a> is the type of <em>arrow</em> in <span class="math inline">\(A\)</span> from <span class="math inline">\(x\)</span> to <span class="math inline">\(y\)</span>.</li>
<li><em>Definition:</em> A type <span class="math inline">\(A\)</span> is an <em><span class="math inline">\(\infty\)</span>-groupoid</em> if <span class="math inline">\(path{\text -}to{\text -}arr : x =_A y \rightarrow hom_A(x, y)\)</span> is an equivalence.</li>
</ul>
<blockquote>
<p><span class="math inline">\(refl_x \mapsto id_x\)</span></p>
</blockquote>
<ul>
<li><em>Definition:</em> A type <span class="math inline">\(A\)</span> is a <em>pre-<span class="math inline">\(\infty\)</span>-category</em> if every composable pair of arrows has <strong>a unique composite</strong>: for all <span class="math inline">\(f : hom_A(x, y)\)</span> and <span class="math inline">\(g : hom_A(y, z)\)</span> the type <span class="math inline">\(\left\{ \array{ \Lambda^2_1 &amp; \xrightarrow{f, g} &amp; A \\ \downarrow &amp; \nearrow &amp; \\ \Delta^2 &amp; &amp; } \right\}\)</span> <a href="#footnote-2"><sup>2</sup></a> <a id="footnote-ref-1"></a> is contractible.</li>
<li><em>Notation:</em> Denote the <strong>unique</strong> inhabitant by:
<p align="center">
<img alt="comp g f" src="compgf.png">
</p></li>
</ul>
<p>In any <em>pre-<span class="math inline">\(\infty\)</span>-category</em> <span class="math inline">\(A\)</span>:</p>
<details>
<summary> <em>Lemma:</em> Each <span class="math inline">\(x : A\)</span> has an <em>identity arrow</em> <span class="math inline">\(id_x : hom_A(x, x)\)</span> so that for all <span class="math inline">\(f : hom_A(x, y)\)</span> and all <span class="math inline">\(k : hom_A(w, x)\)</span>, <span class="math inline">\(f \cdot id_x = f\)</span> and <span class="math inline">\(id_x \cdot k = k\)</span>. </summary>
<p>
Proof: The constant function defines a term <span class="math inline">\(id_x :\equiv \lambda t . x : hom_A(x, x) :\equiv \left\{ \array{ \partial \Delta&#39; &amp; \xrightarrow{(x, x)} &amp; A \\ \downarrow &amp; \nearrow &amp; \\ \Delta&#39; &amp; &amp; } \right\}\)</span> <a href="#footnote-2"><sup>2</sup></a> <a id="footnote-ref-1"></a>. The type <span class="math inline">\(\left\{ \array{ \Lambda^2_1 &amp; \xrightarrow{id_x, f} &amp; A \\ \downarrow &amp; \nearrow &amp; \\ \Delta^2 &amp; &amp;} \right\}\)</span> <a href="#footnote-2"><sup>2</sup></a> <a id="footnote-ref-1"></a> is inhabited by <span class="math inline">\(\lambda s \lambda t, f(t) : \Delta^2 \rightarrow A\)</span>, proving <span class="math inline">\(f \circ id_x = f\)</span>. <span class="math inline">\(\square\)</span>
</p>
</details>
<p>(WIP)</p>
<h2 id="my-notes">My notes</h2>
<ol type="1">
<li><a id="footnote-1"></a> <a href="#footnote-ref-1"><sup>↑</sup></a> The two computation rules are <span class="math inline">\(\beta\)</span><em>-reduction</em> and <span class="math inline">\(\eta\)</span><em>-reduction</em></li>
<li><a id="footnote-2"></a> <a href="#footnote-ref-2"><sub>↑</sup></a> Some hook arrows and dashed arrows are omitted for limitations of inline <span class="math inline">\(\TeX\)</span></li>
</ol>

    </article>
  </main>

  <footer>
    Too long, didn't write.
  </footer>

  <script
    type="text/javascript"
    async
    src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
  </script>
</body>

</html>
